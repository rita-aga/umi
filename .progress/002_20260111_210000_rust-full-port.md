# Full Rust Port - Umi Memory Library

## Status: In Progress - Phase 0 Complete

## Overview

Port the Python layer (`umi/`) to Rust, creating a fully Rust implementation with simulation-first architecture. The existing DST harness provides foundations; we need to extend it for LLM simulation and port the memory components.

---

## Current State Analysis

### Existing Rust DST Infrastructure
- `SimConfig` - Seed-based configuration
- `DeterministicRng` - Reproducible randomness
- `SimClock` - Controlled time
- `SimStorage` - Storage simulation
- `SimNetwork` - Network simulation with partitions/latency/faults
- `FaultInjector` - Fault injection framework
- Property-based testing framework

### What Needs to Be Built
1. **LLM Simulation Layer** - Missing from Rust DST
2. **LLM Provider Trait** - Interface for sim/production providers
3. **EntityExtractor** - Port from Python
4. **DualRetriever** - Port from Python
5. **EvolutionTracker** - Port from Python
6. **Memory API** - High-level `remember()`/`recall()` interface

---

## Phase 0: Extend DST for LLM Simulation

**Goal**: Add LLM simulation primitives to the DST harness

### 0.1 SimLLM Module
Create `umi-core/src/dst/llm.rs`:

```rust
pub struct SimLLM {
    rng: DeterministicRng,
    fault_injector: Arc<FaultInjector>,
}

impl SimLLM {
    pub async fn complete(&self, prompt: &str) -> Result<String, LLMError>;
    pub async fn complete_json<T: DeserializeOwned>(&self, prompt: &str) -> Result<T, LLMError>;

    // Internal routing
    fn route_prompt(&self, prompt: &str) -> String;
    fn sim_entity_extraction(&self, prompt: &str) -> String;
    fn sim_query_rewrite(&self, prompt: &str) -> String;
    fn sim_evolution_detection(&self, prompt: &str) -> String;
}
```

### 0.2 LLM Error Types
```rust
pub enum LLMError {
    Timeout,
    RateLimit,
    ApiError(String),
    MalformedResponse(String),
    NetworkError(NetworkError),
}
```

### 0.3 LLM Fault Types
Add to `FaultType` enum:
- `LLMTimeout`
- `LLMRateLimit`
- `LLMApiError`
- `LLMMalformed`

### 0.4 Update SimEnvironment
```rust
pub struct SimEnvironment {
    pub clock: SimClock,
    pub storage: SimStorage,
    pub network: SimNetwork,
    pub llm: SimLLM,  // NEW
    pub fault_injector: Arc<FaultInjector>,
}
```

### Files to Create/Modify
- [x] `umi-core/src/dst/llm.rs` - NEW: SimLLM implementation (706 lines, 14 tests)
- [x] `umi-core/src/dst/mod.rs` - Export SimLLM, LLMError
- [x] `umi-core/src/constants.rs` - Add LLM_* constants
- [x] `umi-core/src/dst/simulation.rs` - Add SimLLM to SimEnvironment
- [x] `docs/adr/012-sim-llm.md` - ADR for SimLLM design
- Note: LLM fault types already existed in `fault.rs`

---

## Phase 1: LLM Provider Trait & Implementations

**Goal**: Define LLM interface and implement sim + real providers

### 1.1 LLM Provider Trait
Create `umi-core/src/llm/mod.rs`:

```rust
#[async_trait]
pub trait LLMProvider: Send + Sync {
    async fn complete(&self, prompt: &str) -> Result<String, LLMError>;
    async fn complete_json<T: DeserializeOwned>(&self, prompt: &str) -> Result<T, LLMError>;
}
```

### 1.2 Providers
- `SimLLMProvider` - Wraps DST SimLLM
- `AnthropicProvider` - Claude API via reqwest
- `OpenAIProvider` - OpenAI API via reqwest

### Files to Create
- [ ] `umi-core/src/llm/mod.rs` - Trait + errors
- [ ] `umi-core/src/llm/sim.rs` - SimLLMProvider
- [ ] `umi-core/src/llm/anthropic.rs` - Anthropic provider
- [ ] `umi-core/src/llm/openai.rs` - OpenAI provider

---

## Phase 2: Entity Extraction

**Goal**: Port EntityExtractor to Rust

### 2.1 Data Types
```rust
pub struct ExtractedEntity {
    pub name: String,
    pub entity_type: EntityType,
    pub content: String,
    pub confidence: f64,
}

pub struct ExtractedRelation {
    pub source: String,
    pub target: String,
    pub relation_type: RelationType,
    pub confidence: f64,
}

pub struct ExtractionResult {
    pub entities: Vec<ExtractedEntity>,
    pub relations: Vec<ExtractedRelation>,
    pub raw_text: String,
}
```

### 2.2 EntityExtractor
```rust
pub struct EntityExtractor<P: LLMProvider> {
    llm: P,
    seed: Option<u64>,
}

impl<P: LLMProvider> EntityExtractor<P> {
    pub async fn extract(
        &self,
        text: &str,
        existing_entities: Option<&[String]>,
    ) -> Result<ExtractionResult, ExtractionError>;
}
```

### Files to Create
- [ ] `umi-core/src/extraction/mod.rs` - Types + EntityExtractor
- [ ] `umi-core/src/extraction/types.rs` - Data structures
- [ ] `umi-core/src/extraction/prompts.rs` - Prompt templates

---

## Phase 2.5: Storage Backends

**Goal**: Unified storage trait with SimStorage (DST) and LanceDB (production)

### Research Summary

| Database | Status | Vector Search | DST-Friendly | Decision |
|----------|--------|---------------|--------------|----------|
| Turso/Limbo | Beta (not ready) | ✅ DiskANN | ✅ Built-in | Future option |
| **LanceDB** | **1.0.0 stable** | ✅ IVF/HNSW | ⚠️ Custom | **Selected** |
| Qdrant | Production | ✅ HNSW | ⚠️ Custom | Alternative |
| FoundationDB | Production | ❌ None | ✅ Legendary | Overkill |

**Decision**: LanceDB for production (used by Midjourney, Runway, Character.ai at scale)

### 2.5.1 Storage Trait

```rust
#[async_trait]
pub trait StorageBackend: Send + Sync {
    /// Store an entity, returns assigned ID
    async fn store(&self, entity: Entity) -> Result<String, StorageError>;

    /// Get entity by ID
    async fn get(&self, id: &str) -> Result<Option<Entity>, StorageError>;

    /// Delete entity by ID
    async fn delete(&self, id: &str) -> Result<bool, StorageError>;

    /// Search by text (substring match)
    async fn search(&self, query: &str, limit: usize) -> Result<Vec<Entity>, StorageError>;

    /// Search by vector similarity
    async fn search_vector(
        &self,
        embedding: &[f32],
        limit: usize,
    ) -> Result<Vec<(Entity, f32)>, StorageError>;

    /// Search by time range
    async fn search_time_range(
        &self,
        start: DateTime<Utc>,
        end: DateTime<Utc>,
        limit: usize,
    ) -> Result<Vec<Entity>, StorageError>;
}
```

### 2.5.2 SimStorage (Already Exists)

Extend existing `SimStorageBackend` to implement new trait:
- In-memory HashMap storage
- Deterministic with seed
- Simulated vector search (exact match fallback)
- Full DST support

### 2.5.3 LanceStorage (New)

```rust
pub struct LanceStorage {
    db: lancedb::Connection,
    table_name: String,
}

impl LanceStorage {
    pub async fn open(path: &str) -> Result<Self, StorageError>;
    pub async fn open_in_memory() -> Result<Self, StorageError>;
}

impl StorageBackend for LanceStorage {
    // Implement using LanceDB's native APIs
    // - Arrow-based entity storage
    // - IVF/HNSW vector indexing
    // - SQL-like filtering for time ranges
}
```

### 2.5.4 Storage Schema

```rust
/// Entity storage schema for LanceDB (Arrow-compatible)
pub struct EntityRecord {
    pub id: String,
    pub name: String,
    pub entity_type: String,
    pub content: String,
    pub importance: f32,
    pub confidence: f32,
    pub document_time: i64,      // Unix timestamp
    pub event_time: Option<i64>, // Unix timestamp
    pub embedding: Vec<f32>,     // Vector for similarity search
    pub metadata: String,        // JSON blob
}
```

### Files to Create/Modify
- [ ] `umi-core/src/storage/mod.rs` - Update with new trait
- [ ] `umi-core/src/storage/sim.rs` - Extend SimStorageBackend
- [ ] `umi-core/src/storage/lance.rs` - NEW: LanceDB implementation
- [ ] `umi-core/src/storage/schema.rs` - NEW: Arrow schema definitions

### DST Strategy for LanceDB

Since LanceDB doesn't have built-in DST:
1. **Use SimStorage for all DST tests** (deterministic)
2. **Integration tests for LanceDB** (non-deterministic but thorough)
3. **Golden tests** to verify SimStorage ↔ LanceDB behavior parity

---

## Phase 3: Dual Retrieval

**Goal**: Port DualRetriever to Rust

### 3.1 DualRetriever
```rust
pub struct DualRetriever<P: LLMProvider, S: StorageBackend> {
    storage: S,
    llm: P,
    seed: Option<u64>,
}

impl<P, S> DualRetriever<P, S> {
    pub async fn search(
        &self,
        query: &str,
        limit: usize,
        deep_search: bool,
        time_range: Option<(DateTime<Utc>, DateTime<Utc>)>,
    ) -> Result<Vec<Entity>, RetrievalError>;

    pub fn needs_deep_search(&self, query: &str) -> bool;
    pub async fn rewrite_query(&self, query: &str) -> Result<Vec<String>, RetrievalError>;
    pub fn merge_rrf(&self, result_lists: &[Vec<Entity>], k: usize) -> Vec<Entity>;
}
```

### Files to Create
- [ ] `umi-core/src/retrieval/mod.rs` - DualRetriever
- [ ] `umi-core/src/retrieval/heuristics.rs` - Deep search detection
- [ ] `umi-core/src/retrieval/rrf.rs` - Reciprocal Rank Fusion

---

## Phase 4: Evolution Tracking

**Goal**: Port EvolutionTracker to Rust

### 4.1 Evolution Types
```rust
pub enum EvolutionType {
    Update,
    Extend,
    Derive,
    Contradict,
}

pub struct EvolutionRelation {
    pub source_id: String,
    pub target_id: String,
    pub evolution_type: EvolutionType,
    pub reason: String,
    pub confidence: f64,
}
```

### 4.2 EvolutionTracker
```rust
pub struct EvolutionTracker<P: LLMProvider, S: StorageBackend> {
    llm: P,
    storage: S,
    seed: Option<u64>,
}

impl<P, S> EvolutionTracker<P, S> {
    pub async fn detect(
        &self,
        new_entity: &Entity,
        existing_entities: &[Entity],
    ) -> Result<Option<EvolutionRelation>, EvolutionError>;
}
```

### Files to Create
- [ ] `umi-core/src/evolution/mod.rs` - EvolutionTracker
- [ ] `umi-core/src/evolution/types.rs` - EvolutionType, EvolutionRelation

---

## Phase 5: Memory API

**Goal**: High-level Memory interface like Python's Memory class

### 5.1 Memory Struct
```rust
pub struct Memory<P: LLMProvider, S: StorageBackend> {
    extractor: EntityExtractor<P>,
    retriever: DualRetriever<P, S>,
    evolution: EvolutionTracker<P, S>,
    storage: S,
    seed: Option<u64>,
}

impl<P, S> Memory<P, S> {
    pub async fn remember(
        &self,
        text: &str,
        options: RememberOptions,
    ) -> Result<Vec<Entity>, MemoryError>;

    pub async fn recall(
        &self,
        query: &str,
        options: RecallOptions,
    ) -> Result<Vec<Entity>, MemoryError>;
}
```

### 5.2 Builder Pattern
```rust
pub struct MemoryBuilder {
    seed: Option<u64>,
    provider: ProviderType,
    // ...
}

impl MemoryBuilder {
    pub fn with_seed(seed: u64) -> Self;
    pub fn with_provider(provider: ProviderType) -> Self;
    pub fn build(self) -> Result<Memory<...>, BuildError>;
}
```

### Files to Create
- [ ] `umi-core/src/api/mod.rs` - Memory struct
- [ ] `umi-core/src/api/builder.rs` - MemoryBuilder
- [ ] `umi-core/src/api/options.rs` - RememberOptions, RecallOptions

---

## Phase 6: Integration Tests

**Goal**: Comprehensive DST-based testing

### Test Categories
1. **Determinism tests** - Same seed = same results
2. **Fault injection tests** - All components handle faults gracefully
3. **Property tests** - Invariants hold across random inputs
4. **Integration tests** - Full remember/recall workflows

### Files to Create
- [ ] `umi-core/tests/dst_llm.rs` - SimLLM tests
- [ ] `umi-core/tests/extraction.rs` - EntityExtractor tests
- [ ] `umi-core/tests/retrieval.rs` - DualRetriever tests
- [ ] `umi-core/tests/evolution.rs` - EvolutionTracker tests
- [ ] `umi-core/tests/memory_api.rs` - Memory integration tests
- [ ] `umi-core/tests/storage_lance.rs` - LanceDB backend tests (non-DST)
- [ ] `umi-core/tests/storage_parity.rs` - SimStorage ↔ LanceDB behavior parity

---

## Implementation Order

```
Phase 0: DST LLM Extension
    └── SimLLM, LLM faults
         │
Phase 1: LLM Providers  ──────────────────┐
    └── Trait + Sim + Anthropic + OpenAI  │
         │                                 │
Phase 2: EntityExtractor ─────────────────┤
         │                                 │
Phase 2.5: Storage Backends ──────────────┤
    └── StorageBackend trait              │
    └── SimStorage (extend existing)      │
    └── LanceStorage (new)                │
         │                                 │
Phase 3: DualRetriever ───────────────────┘
         │
Phase 4: EvolutionTracker
         │
Phase 5: Memory API
         │
Phase 6: Integration Tests
```

### Parallel Work Possible

```
┌─────────────────┐     ┌─────────────────┐
│ Phase 0: SimLLM │     │                 │
└────────┬────────┘     │                 │
         │              │                 │
┌────────▼────────┐     │                 │
│ Phase 1: LLM    │     │                 │
│ Providers       │     │                 │
└────────┬────────┘     │                 │
         │              │                 │
┌────────▼────────┐     ┌────────▼────────┐
│ Phase 2: Entity │     │ Phase 2.5:      │
│ Extraction      │     │ Storage         │  ← Can run in parallel
└────────┬────────┘     └────────┬────────┘
         │                       │
         └───────────┬───────────┘
                     │
         ┌───────────▼───────────┐
         │ Phase 3-6: Retrieval, │
         │ Evolution, API, Tests │
         └───────────────────────┘
```

---

## TigerStyle Compliance

Every component must follow:

1. **Preconditions**: Assert inputs at function entry
2. **Postconditions**: Assert outputs before return
3. **Explicit limits**: All sizes, counts have defined MAX constants
4. **Simulation mode**: Every external call has sim equivalent
5. **Determinism**: Same seed produces same results

Example:
```rust
pub async fn extract(&self, text: &str) -> Result<ExtractionResult, ExtractionError> {
    // Preconditions
    debug_assert!(!text.is_empty(), "text must not be empty");
    debug_assert!(text.len() <= TEXT_BYTES_MAX, "text exceeds limit");

    // ... implementation ...

    // Postconditions
    debug_assert!(result.entities.len() <= ENTITIES_MAX);
    Ok(result)
}
```

---

## Dependencies to Add

```toml
[dependencies]
async-trait = "0.1"
reqwest = { version = "0.12", features = ["json"], optional = true }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
thiserror = "2.0"
chrono = { version = "0.4", features = ["serde"] }

# Storage backends
lancedb = { version = "0.15", optional = true }
arrow = { version = "53", optional = true }

[features]
default = ["sim"]
sim = []
anthropic = ["reqwest"]
openai = ["reqwest"]
lance = ["lancedb", "arrow"]
full = ["anthropic", "openai", "lance"]
```

### Feature Matrix

| Feature | Dependencies | Use Case |
|---------|-------------|----------|
| `sim` (default) | None | DST testing, no external calls |
| `anthropic` | reqwest | Claude API integration |
| `openai` | reqwest | OpenAI API integration |
| `lance` | lancedb, arrow | Production vector storage |
| `full` | All above | Full production deployment |

---

## Success Criteria

- [ ] All 232 existing Rust tests pass
- [ ] New tests for all ported components
- [ ] Same behavior as Python layer (verified via golden tests)
- [ ] Full DST coverage (fault injection, determinism)
- [ ] Documentation with examples
- [ ] `cargo clippy` clean
- [ ] `cargo fmt` clean

---

## Estimated Scope

| Phase | Components | Complexity |
|-------|------------|------------|
| 0 | SimLLM + faults | Medium |
| 1 | Provider trait + 3 impls | Medium |
| 2 | EntityExtractor | Medium |
| 2.5 | Storage trait + LanceDB | Medium-High |
| 3 | DualRetriever | Medium-High |
| 4 | EvolutionTracker | Medium |
| 5 | Memory API | Medium |
| 6 | Integration tests | Medium |

---

## Questions Resolved

1. ~~Which components first?~~ → All, starting with DST extension
2. ~~LLM providers?~~ → Sim + Anthropic + OpenAI
3. ~~PyO3 bindings?~~ → Rust-only for now
4. ~~Storage backends?~~ → **LanceDB** (production-ready, used at scale)
   - Researched: Turso/Limbo (beta, not ready), FoundationDB (no vectors), Qdrant, SurrealDB
   - Selected LanceDB: SDK 1.0.0 stable, used by Midjourney/Runway/Character.ai
   - Strategy: SimStorage for DST, LanceDB for production

---

## Future Considerations

- **Turso/Limbo**: Re-evaluate when stable (Q4 2025+) - has native DST
- **Qdrant**: Alternative if need distributed vector search at scale
- **Embedding generation**: Add embedding provider trait for vector creation

---

## History

- 2026-01-11: Plan created based on feasibility analysis in `docs/findings-summary.md`
- 2026-01-11: Added Phase 2.5 (Storage Backends) with LanceDB after research
  - Evaluated: Turso/Limbo, LanceDB, Qdrant, FoundationDB, SurrealDB, redb
  - Decision: LanceDB for production (stable), SimStorage for DST
- 2026-01-11: **Phase 0 Complete** - SimLLM implemented
  - Created `umi-core/src/dst/llm.rs` (706 lines)
  - 14 new tests, all passing (246 total tests)
  - ADR-012 documents design decisions
  - SimEnvironment now includes `llm: SimLLM` field
  - Simulation harness `with_llm_faults()` already existed
