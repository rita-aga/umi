# Phase 3: True Dual Retrieval with Vector Search

**Task**: Add semantic vector search to DualRetriever - DST-driven
**Status**: In Progress
**Started**: 2026-01-12
**Plan File**: `003_20260112_160000_phase3-dual-retrieval.md`

---

## Context

Phase 2 wired embeddings into Memory.remember(). Now entities have embeddings stored, but DualRetriever still only does text search. Phase 3 implements TRUE dual retrieval:
- **Fast path**: Vector similarity search using embeddings
- **Deep path**: LLM query rewriting + vector search
- **RRF merge**: Combine results from both paths

**Critical Principle**: DST-DRIVEN
- Implement with SimVectorBackend (already exists!)
- Torture test with fault injection
- Find edge cases before production
- Zero production dependencies

---

## Current State Analysis

### DualRetriever Today (Text-Only)

From `umi-memory/src/retrieval/mod.rs`:
- Fast path: Direct text search via `storage.search(query)`
- Deep path: LLM rewrites query, searches each variant
- RRF merge: Combines results with Reciprocal Rank Fusion

**Problem**: No vector search! Just doing multiple text searches.

### What Exists Already

1. **SimVectorBackend** - In-memory vector search with cosine similarity
2. **Entity.embedding** - Field exists, now populated (Phase 2)
3. **RRF merge** - Already implemented in DualRetriever
4. **Fault injection** - FaultType::VectorSearchFail exists in DST

---

## Objectives

1. Add VectorBackend to DualRetriever
2. Implement vector similarity search in fast path
3. Update deep path to use vector search after query rewrite
4. Keep text search as fallback when embeddings missing
5. Write DST tests with fault injection
6. Verify determinism and graceful degradation

---

## Architecture Changes

### Current DualRetriever
```rust
pub struct DualRetriever<L: LLMProvider, S: StorageBackend> {
    llm: L,
    storage: S,
}
```

### Target DualRetriever
```rust
pub struct DualRetriever<L: LLMProvider, E: EmbeddingProvider, V: VectorBackend, S: StorageBackend> {
    llm: L,
    embedder: E,        // NEW - for query embedding
    vector: V,          // NEW - for vector search
    storage: S,         // Keep for text fallback
}
```

---

## Implementation Plan

### Phase 3.1: Update DualRetriever Struct

**File**: `umi-memory/src/retrieval/mod.rs`

**Tasks**:
- [ ] Add EmbeddingProvider generic
- [ ] Add VectorBackend generic
- [ ] Add embedder and vector fields
- [ ] Update constructor to accept 4 parameters
- [ ] Update Memory to pass embedder and vector backend

**Design Notes**:
- Keep storage for text fallback
- Breaking change to DualRetriever::new() is OK
- Memory will need to create/pass VectorBackend

### Phase 3.2: Implement Vector Search in Fast Path

**File**: `umi-memory/src/retrieval/mod.rs`

**Tasks**:
- [ ] In fast_search: Generate embedding for query
- [ ] Search vector backend with query embedding
- [ ] Fetch entities by IDs from storage
- [ ] Fallback to text search if embedding fails
- [ ] Return results sorted by similarity

**Algorithm**:
```rust
async fn fast_search(&self, query: &str, limit: usize) -> Result<Vec<Entity>> {
    // Try vector search first
    match self.embedder.embed(query).await {
        Ok(query_embedding) => {
            // Vector search
            let results = self.vector.search(&query_embedding, limit).await?;

            // Fetch entities by ID
            let mut entities = Vec::new();
            for result in results {
                if let Some(entity) = self.storage.get_entity(&result.id).await? {
                    entities.push(entity);
                }
            }
            Ok(entities)
        }
        Err(e) => {
            // Graceful degradation: fallback to text search
            tracing::warn!("Vector search failed: {}, falling back to text", e);
            self.storage.search(query, limit).await
        }
    }
}
```

### Phase 3.3: Update Deep Path with Vector Search

**File**: `umi-memory/src/retrieval/mod.rs`

**Tasks**:
- [ ] After LLM rewrites query, embed each variant
- [ ] Vector search for each query variant
- [ ] Merge results with RRF (already implemented)
- [ ] Graceful degradation on failures

**Algorithm**:
```rust
async fn deep_search(&self, query: &str, limit: usize) -> Result<Vec<Entity>> {
    // LLM rewrites query (existing)
    let variants = self.llm.rewrite_query(query).await?;

    // Vector search each variant
    let mut all_results = Vec::new();
    for variant in variants {
        match self.embedder.embed(&variant).await {
            Ok(embedding) => {
                if let Ok(results) = self.vector.search(&embedding, limit).await {
                    all_results.push(results);
                }
            }
            Err(_) => {
                // Fallback to text for this variant
                if let Ok(results) = self.storage.search(&variant, limit).await {
                    all_results.push(results);
                }
            }
        }
    }

    // RRF merge (existing logic)
    Ok(self.rrf_merge(all_results, limit))
}
```

### Phase 3.4: Update Memory to Wire VectorBackend

**File**: `umi-memory/src/umi/mod.rs`

**Tasks**:
- [ ] Create SimVectorBackend in Memory::new()
- [ ] Pass to DualRetriever constructor
- [ ] Ensure entities are stored in vector backend after embedding
- [ ] Update tests to verify vector search works

**Integration**:
```rust
impl Memory {
    pub fn new(llm: L, embedder: E, storage: S) -> Self {
        // Create vector backend (shares storage backend's config)
        let vector = SimVectorBackend::new(seed);

        // Pass to retriever
        let retriever = DualRetriever::new(llm.clone(), embedder.clone(), vector, storage.clone());

        Self { storage, extractor, retriever, evolution, embedder }
    }
}
```

### Phase 3.5: Store Embeddings in VectorBackend

**File**: `umi-memory/src/umi/mod.rs`

**Tasks**:
- [ ] After entity storage in remember(), store embedding in vector backend
- [ ] Handle vector storage failures gracefully
- [ ] Ensure entity ID matches between storage and vector backend

**Algorithm in remember()**:
```rust
// After storing entity in storage
for entity in to_store {
    let stored_id = self.storage.store_entity(&entity).await?;

    // Store embedding in vector backend
    if let Some(ref embedding) = entity.embedding {
        if let Err(e) = self.vector.store(&stored_id, embedding).await {
            tracing::warn!("Failed to store embedding in vector backend: {}", e);
            // Continue - entity is in storage, just not searchable by vector
        }
    }
}
```

---

## DST Testing Strategy

### Fault Injection Scenarios

1. **Vector Search Timeout** (100% failure)
   - Verify fallback to text search
   - Verify results still returned

2. **Embedding Generation Fails** (50% failure)
   - Fast path: some queries use vector, some text
   - Deep path: mixed vector/text for variants

3. **Vector Backend Corruption**
   - Wrong dimensions returned
   - Verify graceful handling

4. **Partial Vector Storage Failure**
   - Some embeddings stored, some fail
   - Verify mixed results work

5. **Storage vs Vector Mismatch**
   - Entity in storage but not vector
   - Verify text fallback works

### DST Tests (Plan: 8 new tests)

1. `test_recall_with_vector_search` - Basic vector search works
2. `test_recall_vector_search_timeout` - Fallback to text
3. `test_recall_embedding_fails` - Graceful degradation
4. `test_recall_vector_deterministic` - Same seed = same ranking
5. `test_recall_mixed_vector_text` - Handles entities with/without embeddings
6. `test_recall_deep_search_vector` - Deep path uses vector
7. `test_recall_rrf_with_vector` - RRF merges vector results
8. `test_recall_vector_storage_partial_failure` - Some embeddings fail to store

---

## Success Criteria

- [ ] DualRetriever updated with embedder and vector backend
- [ ] Fast path uses vector similarity search
- [ ] Deep path uses vector search for each query variant
- [ ] Graceful fallback to text search on failures
- [ ] All existing tests pass (with updated constructors)
- [ ] 8 new DST tests with fault injection
- [ ] Determinism verified: same seed = same ranking
- [ ] Zero production dependencies in tests

---

## File Manifest

**Modified**:
- `umi-memory/src/retrieval/mod.rs` - DualRetriever with vector search
- `umi-memory/src/umi/mod.rs` - Wire vector backend, store embeddings
- `umi-memory/src/storage/vector.rs` - May need minor updates

---

## Dependencies

**Already Exists**:
- SimVectorBackend with cosine similarity
- VectorBackend trait
- Entity.embedding field
- RRF merge logic

**No new dependencies!**

---

## Phase Tracking

### Instance Log
- **Instance 1** (Primary): Working on Phase 3.1-3.5

---

## Findings & Notes

### Pre-Implementation Review

**TODO**: Read current DualRetriever implementation
**TODO**: Understand RRF merge logic
**TODO**: Check how vector backend is accessed

---

## Blockers

- None currently

---

## Notes

- Strictly DST-driven - test with fault injection FIRST
- Graceful degradation on all failure paths
- Keep text search as fallback
- Phase 4 will add production storage (LanceDB, PostgreSQL)
